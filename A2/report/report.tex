\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{comment}
\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\pagestyle {plain}
\pagenumbering{arabic}
\newcounter{stepnum}
\title{Assignment 2 Solution}
\author{Daniel Guoussev-Donskoi}
\date{\today}
\begin {document}
\maketitle
This report discusses the testing phase for .... It also discusses the results
of running the same tests on the partner files. The assignment specifications
are then critiqued and the requested discussion questions are answered.
\section{Testing of the Original Program}
My tests were written in such a way that they tested every program with "logic" behind them extensively, but did minimal testing for getters and setters outside of checking for errors and exceptions. This is because the getter and setter functions didn't really have much "logic" behind them, while the more complex ones had potential boundary cases or exceptions to be thrown. My tests all passed up to the sim, which I was unable to develop a method of testing for. I greatly liked the progression of the modules, with us beginning with the most Abstract class, a general shape and making a CircleT object that was a form of shape, with the complexity slowly 
\section{Results of Testing Partner's Code}
For the tests I made, all the exceptions were thrown as needed and the correct values were returned, with the main issues present being specifically rounding errors when I chose to check for a rounded value being returned and my partner did not. 
\section{Critique of Given Design Specification}
While the formal notation was initially harder to interpret or access than one written in natural language, I found that once I began to understand MIS specification, it actually became far more effective at communicating details about the modules in question, specifically, the error cases for each, where exceptions would need to be raised as well as extreme clarity about the parameters that would be passed to each function and what was expected to be returned. I also found it extremely effective for the way certain modules inherited from other more abstract modules, and clearly illustrated how each should inherit from it's "parent" and behave.
\section{Answers}
\begin{enumerate}[a)]
\item As getters and setters don't really contain any "logic" they don't have to be unit tested because they're not executing a set of logical instructions, they're simply getting or setting what they're being told to set. Thus, a unit test will not really reveal any relevant information about a getter or a setter.
\item As said getters and setters are actually employed in the context of the Scene module, and set the unbalanced forces necessary for it, I would use Scene's built in method to get the unbalanced forces and compare it to an expected result for both Fx and Fy, thereby testing the getters and setters in question.
\item Matplotlib includes packages to compare two graphs or images produced by it, thus we could use compare images to examine a graph we had already produced against the one generated by Plot.py and return a boolean True or False depending on whether it was "close enough".
        
\item
Math Specification:
\medskip
closeenough: (seq of $\mathbb{R}$ x seq of $\mathbb{R}$) \rightarrow $Bool$ 
\medskip
closeenough = ( +i : $\mathbb{R}$ $|$ i $\in$ [0..$|$ $x_{true}$ $|$ - 1 ] : ($x_{calc}$ - $x_{true}$) $|$ ) / ( +i : $\mathbb{R}$ $|$ i $\in$ [0..$|$ $x_{true}$ $|$ - 1] : $|$ $x_{true}$ $|$ ) $<$ $\epsilon$
\item Such an exception would be unnecessary as while the idea of "negative mass" or "negative length" are fundamentally nonsensical, we can have a negative position or speed, if we look at it in terms of velocity. After all, a body can move downwards when it's initial vertical velocity was positive, due to the effect of gravity. Thus, from a physics point of view and a programming point of view there is no need for such an exception.
\item The specification clearly outlined that an exception should be returned in the event that either m or s were not greater than zero. From this, we can logically determine that $m > 0$ and $s > 0$ as if either of them were not, value error would have been raised thus $m > 0$ and $s > 0$
\item sqrt(x) for x in range(5,20) if x mod 2 == 1
\item 
\begin{verbatim}
def upperremover(string): 
        purgedstring = " " 
        for character in string: 
            if (character.isupper() == False): 
                purgedstring = purgedstring + character 
        return purgedstring 
\end{verbatim}                
\item Abstraction represents the idea of effectively "ignoring unnecessary details" and focusing on a general template, that can represent multiple types of modules even if they differ on their specifics. Generality on the other hand, is the idea of representing multiple modules by focusing UPON the details and seeing what common details they have that makes the properties used in one similar to another.
\item It makes far more sense to have a single module inherited by many other modules than a module that inherits from many modules as while many inheriting one reduces complexity view abstraction, the other enhances it by adding many more moving parts to a single module which rather than simplifying anything, makes the module exponentially more complicated to understand and determine the issues with.
\end{enumerate}
\newpage
\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}
\def\thesection{\Alph{section}}
\section{Code for Shape.py}
\noindent \lstinputlisting{../src/Shape.py}
\newpage
\section{Code for CircleT.py}
\noindent \lstinputlisting{../src/CircleT.py}
\newpage
\section{Code for TriangleT.py}
\noindent \lstinputlisting{../src/TriangleT.py}
\newpage
\section{Code for BodyT.py}
\noindent \lstinputlisting{../src/BodyT.py}
\newpage
\section{Code for Scene.py}
\noindent \lstinputlisting{../src/Scene.py}
\newpage
\section{Code for Plot.py}
\noindent \lstinputlisting{../src/Plot.py}
\newpage
\section{Code for test\_All.py}
\noindent \lstinputlisting{../src/test_All.py}
\newpage
\section{Code for Partner's CircleT.py}
\noindent \lstinputlisting{../partner/CircleT.py}
\newpage
\section{Code for Partner's TriangleT.py}
\noindent \lstinputlisting{../partner/TriangleT.py}
\newpage
\section{Code for Partner's BodyT.py}
\noindent \lstinputlisting{../partner/BodyT.py}
\newpage
\section{Code for Partner's Scene.py}
\noindent \lstinputlisting{../partner/Scene.py}
\newpage
\end {document}

